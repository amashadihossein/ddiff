---
title: "A Quick Start Guide to R Package ‘ddiff’"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{A Quick Start Guide to R Package ‘ddiff’}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

This vigette was partally based on the github page given below 

> "Introduction to Data diff package."
([link](https://amashadihossein.github.io/ddiff/))

## Installing the package

```{r, eval=FALSE}
install.packages("ddiff")
```

To install the (development) GitHub version, you could use 
```{r, eval=FALSE}
devtools::install_github("amashadihossein/ddiff") 
```

# Form content comparsion

First, we need to load the package and generate the simulated datasets : 
```{r results='markup'}
library(ddiff)
d <- generate_test_data(50)
```

To compare two datasets, simply pass them to the `ddiff_form` function:
## When data tables being compared are identical
```{r results='markup'}
ddiff_rpt <- ddiff_form(d$identical$new, d$identical$old, "id")
```

The structure of the output is a list which contains 7 indicator given below and `arsenal::comparedf` object. For more details and useage of the `arsenal::comparedf`, please refer [vignettes](https://cran.r-project.org/web/packages/arsenal/vignettes/comparedf.html) for more detail regarding generating SAS-like report from comparedf object. 

The each indicator is corresponding to the following criterion:

- When data tables being compared are identical : identical
- When order of columns and rows are changed : info_match
- When attributes are the same but content change : attributes_match
- When attributes change but colnames are the same : column_match
- When attributes change and colnames are different too : row_match
 
```{r results='markup'}
ddiff_rpt[-7]
ddiff_rpt[7]
```

## When order of columns and rows are changed
```{r results='markup'}
ddiff_rpt <- ddiff_form(d$order$new, d$order$old, "id")
ddiff_rpt
```

## When attributes are the same but content change
```{r results='markup'}
ddiff_rpt <- ddiff_form(d$attrs$same$new, d$attrs$same$old, "id")
ddiff_rpt
```

## When attributes change but colnames are the same
```{r results='markup'}
ddiff_rpt <- ddiff_form(d$attrs$different$col_same$new, d$attrs$different$col_same$old, "id")
ddiff_rpt
```

## When attributes change and colnames are different too
```{r results='markup'}
ddiff_rpt <- ddiff_form(d$attrs$different$col_diff$new, d$attrs$different$col_diff$old, "id")
ddiff_rpt
```

## When new records are added to a table
```{r results='markup'}
ddiff_rpt <- ddiff_form(d$records_added$new, d$records_added$old, "id")
ddiff_rpt
```

# Information content comparsion
There are two main categories we are looking at when we compare datasets which are individual difference on each variables in each datasets and groups difference. 

## Univariate information diff
For each individual variable, there are three main types of variables which are continuous, categorical and binary. The last two could be combined into one category while in pharmaceutical settings,  we make distinction between the two. Before we look into the difference. First, we need to know type of variables in each datasets. The `get_varialbe_class` is designed for this purpose. 

```{r results='markup'}
#information content diff
ddiff_rpt <- get_variable_class(d$identical$new, d$identical$old,"id")
#ddiff_rpt
data.tree::FromListSimple(ddiff_rpt)
str(ddiff_rpt)
```
After knowing the types of variables, we could obtain custom difference metrics on each variables. For example, we could look at the difference by min, max, median, mean and standard error for continuous and frequency difference for categorical and binary variables shown below. 
```{r results='markup'}
result <- get_variable_stat(d$identical$new, d$identical$old, "id")

result$result_con
result$result_cat
result$result_bin
```
## Custom list of metrics 
As shown in the above example, we offer some of the default metrics to look at for each types of variables. You could also apply some custom metrics as shown below. Note that the input metrics must be a list of funciton. 
```{r results='markup'}
result <- get_variable_stat(d$identical$new, d$identical$old, "id", measure_arg_con = list(min = min, max = max, med = median))
result$result_con
result$result_cat
result$result_bin

#You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.
```

