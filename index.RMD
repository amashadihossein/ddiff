---
title: "Data diff"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    theme: paper
    highlight: zenburn
    toc: true
    number_sections: true
    toc_float: true
    code_folding: show
---
# Introduction

In the framework of `daap`, `git` enables joint versioning of data and code. 
Additionally `git` provides deep coverage for change tracking code. However, 
when it comes to data, our ability to track change as at only at a very 
high/metadata level. While, `git` can track changes in text, text change 
tracking is not suitable for tracking data changes.  This leaves a gap in our 
ability to `diff`.

# Related work

Various packages have come along with utilities that could help characterize or 
compare tabular data. Examples include, 
[`compareDF`](https://github.com/alexsanjoseph/compareDF), 
[`waldo`](https://waldo.r-lib.org/index.html), 
[`arsenal`](https://cran.r-project.org/web/packages/arsenal/vignettes/comparedf.html), 
[`janitor`](http://sfirke.github.io/janitor/), and
[`pointblank`](https://rich-iannone.github.io/pointblank/index.html).  
Comparisons provided by these packages, while get us closer to something akin to
a utility that could help us interpret changes as `diff` does, they typically 
fall short.  For example, `compareDF`, as the package that most directly seeks 
to mimic a `git` type `diff` functionality, rather than aiming for what's the 
spirit of diff (i.e. enabling the developer to interpret differences) mimics 
text tracking functionality of `diff`, which as mentioned is not suitable for 
data.  As a concrete example, from information perspective, reordering of 
columns and rows does not change the information-content of a data table. 
However, both `git` and `compareDF` treat row re-arrangement as change by 
default (i.e. when you don't specify a grouping variable). Furthermore, all 
mentioned packages shy away from statistical information tracking. Authors, 
may have thought about and consciously decided to exclude that from the scope of
their projects, given complexities of general purpose tools for what could be 
akin to anomaly detection.  However, given the value of such approaches, even 
limited application of statistical approaches (e.g. finding univariate extreme 
values which is fairly robust), could move us closer to having tools that 
provide actionable `diff` like functionality for data.

# Method:

The illustration below shows a possible step-wise flow to implementing a diff
functionality. ![ddiff appraoch](./index_files/figure-html/ddiff.png) 
Output of a `diff` call generated by this or similar workflow, combines data 
validation type comparison as well as information content type comparison to 
provide more informative,interpretable and ultimately actionable summary of the 
differences.

# Results (preliminary)

The are two components in the outlined workflow:

1. Form or base content diff
2. Information content diff

Form or base content diff is mechanical and quite straight forward to implement.
In contrast, information content `diff` ventures in the realm of unsupervised 
learning and hence more complex.    


## Form and base content `diff`

Here, I implemented the data validation type `diff` and added a minimalist 
venture into the info content `diff` using a simple PCA approach for 
demonstration purposes.

First we simulate some mock data. This is to help us test a few different simple
conditions:

1. When data tables being compared are identical
2. When order of columns and rows are changed
3. When attributes are the same but content change
4. When attributes change but colnames are the same
5. When attributes change and colnames are different too
6. When new records are added to a table

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE)
source("./ddiff.R")
source("./d_test.R")
source("./attr_check.R")
require(dplyr)
require(ggplot2)
```

```{r testdata}
d <- d_test()
data.tree::FromListSimple(d)
```


### Identical

```{r identical}
ddiff_rpt <- ddiff(d_new = d$identical$new, d_old = d$identical$old)
ddiff_rpt[-7] %>%
  as.data.frame() %>%
  dplyr::glimpse()
```

**message:** `r ddiff_rpt$message`

### Change in order

Here, simply the rows and column orders are randomly changed. The resultant 
tables while not identical are equivalent from data perspective.

```{r order}
d$order$old %>%
  head() %>%
  knitr::kable(.)
d$order$new %>%
  head() %>%
  knitr::kable(.)

ddiff_rpt <- ddiff(d_new = d$order$new, d_old = d$order$old)
ddiff_rpt[-7] %>%
  as.data.frame() %>%
  dplyr::glimpse()
```

**message:** `r ddiff_rpt$message`

### Attributes the same but content change

Here, all table attributes are the same, just row content is changed.

```{r attr_same_content_diff}
ddiff_rpt <- ddiff(d_new = d$attrs$same$new, d_old = d$attrs$same$old)
ddiff_rpt[-7] %>%
  as.data.frame() %>%
  dplyr::glimpse()

compareDF::create_output_table(ddiff_rpt$comp_obj)
```

**message:** `r ddiff_rpt$message`

### Attributes different colnames same

Here, there is a single attribute added, but otherwise the contents are the same.

```{r attr_diff_col_same}
ddiff_rpt <- ddiff(d_new = d$attrs$different$col_same$new, d_old = d$attrs$different$col_same$old)
ddiff_rpt[-7] %>%
  as.data.frame() %>%
  dplyr::glimpse()
```

**message:** `r ddiff_rpt$message`

### Attributes different colnames different

Here, a new column is added. As comparability assumes we are comparing the same 
set of features, it alerts the developer to the issue, leaving it to her take 
the right course of action.

```{r attr_diff_col_diff}
ddiff_rpt <- ddiff(d_new = d$attrs$different$col_diff$new, d_old = d$attrs$different$col_diff$old)
ddiff_rpt[-7] %>%
  as.data.frame() %>%
  dplyr::glimpse()
```

**message:** `r ddiff_rpt$message`

### New records added

Here 20 new records are added. All other aspects of the data table attributes 
are the same. `compareDF` does provide `git` like comparison, showing added 
records.  However, you can imagine with larger number of rows and columns added,
the value of visual display of +/- is minimal. Additionally, trends can't be 
spotted. Can you see a difference between rows 21-30 vs. 31-40?

```{r new_records_added}
ddiff_rpt <- ddiff(d_new = d$records_added$new, d_old = d$records_added$old)
ddiff_rpt[-7] %>%
  as.data.frame() %>%
  dplyr::glimpse()

compareDF::create_output_table(ddiff_rpt$comp_obj)
```

**message:** `r ddiff_rpt$message`

## Information content `diff`

### Example of info content type `diff`

Here we look at the same 20 records added using simple PCA analysis.

```{r pca}
prcomp(x = d$records_added$old[, c("nm_1", "nm_2", "nm_3")], retx = T, 
       center = T, scale. = T) -> pc_old

newrecords_sc <- scale(d$records_added$new[-(1:20), c("nm_1", "nm_2", "nm_3")],
                       center = pc_old$center, scale = pc_old$scale)

new_records_hat <- newrecords_sc %*% pc_old$rotation
all_d <- rbind(
  data.frame(source = "old", pc_old$x),
  data.frame(source = "new", new_records_hat)
)

ggplot(all_d, aes(x = PC1, y = PC2)) +
  geom_point(aes(colour = source)) +
  ggsci::scale_color_jama() +
  geom_density_2d() +
  theme_bw() +
  ggtitle("New samples projected on old PC 1,2 space")
```


# Further development

## Univariate information content `diff`

Univariate approach can be considered the "lowest hanging fruit" in implementing
information diff. On binary and categorical front, one could test conformity to 
the existing categories. On continuous variables, both rank-based and parametric
approaches can easily be leveraged.

## Multivariate information content `diff`

Multivariate approach to information content comparison has the most potential 
for enabling data developers to make actionable comparisons between data-sets 
that are being compared.  However, the potential may not easily or fully be 
realized given the degree of complexity involved. Among the multivariate 
approaches, one may dichotomize the problem into those involving plain 
continuous data where the generative model can be reasonably approximated by a 
multivariate distribution (i.e. not censored or repeated measure such as time 
series) and everything else.

### Multivariate `diff` for plain continuous data

Approaches such as matrix factorization, or distance-based anomaly detection 
could be leveraged. An example would be MSD (Modified Stahel-Donoho) estimator

### Mutlivariate `diff` for anything but plain continuous data

Here `diff` is likely to require information to be supplied by the user to the 
algorithm for optimal results. For example, if time course structure is known,
one may be able to make projections or interpolation and evaluate how likely or 
unlikely new data is compared with the old data.


# References:

[1] Wada, Kazumi, and Hiroe Tsubaki. "Parallel computation of modified 
Stahel-Donoho estimators for multivariate outlier detection." 2013 International
Conference on Cloud Computing and Big Data. IEEE, 2013.
